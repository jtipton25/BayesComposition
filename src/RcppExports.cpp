// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/BayesComposition.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// basis_cpp
double basis_cpp(const double& x, const int& degree, const int& i, const arma::vec& knots);
static SEXP BayesComposition_basis_cpp_try(SEXP xSEXP, SEXP degreeSEXP, SEXP iSEXP, SEXP knotsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int& >::type degree(degreeSEXP);
    Rcpp::traits::input_parameter< const int& >::type i(iSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type knots(knotsSEXP);
    rcpp_result_gen = Rcpp::wrap(basis_cpp(x, degree, i, knots));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_basis_cpp(SEXP xSEXP, SEXP degreeSEXP, SEXP iSEXP, SEXP knotsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_basis_cpp_try(xSEXP, degreeSEXP, iSEXP, knotsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// bs_cpp
arma::mat bs_cpp(const arma::vec& x, const int& df, const arma::vec& interior_knots, const int& degree, const bool& intercept, const arma::vec& Boundary_knots);
static SEXP BayesComposition_bs_cpp_try(SEXP xSEXP, SEXP dfSEXP, SEXP interior_knotsSEXP, SEXP degreeSEXP, SEXP interceptSEXP, SEXP Boundary_knotsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int& >::type df(dfSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type interior_knots(interior_knotsSEXP);
    Rcpp::traits::input_parameter< const int& >::type degree(degreeSEXP);
    Rcpp::traits::input_parameter< const bool& >::type intercept(interceptSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type Boundary_knots(Boundary_knotsSEXP);
    rcpp_result_gen = Rcpp::wrap(bs_cpp(x, df, interior_knots, degree, intercept, Boundary_knots));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_bs_cpp(SEXP xSEXP, SEXP dfSEXP, SEXP interior_knotsSEXP, SEXP degreeSEXP, SEXP interceptSEXP, SEXP Boundary_knotsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_bs_cpp_try(xSEXP, dfSEXP, interior_knotsSEXP, degreeSEXP, interceptSEXP, Boundary_knotsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// colSums
arma::vec colSums(const arma::mat& X);
static SEXP BayesComposition_colSums_try(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(colSums(X));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_colSums(SEXP XSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_colSums_try(XSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// d_half_cauchy
double d_half_cauchy(double& x, double& sigma, bool logd);
static SEXP BayesComposition_d_half_cauchy_try(SEXP xSEXP, SEXP sigmaSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double& >::type x(xSEXP);
    Rcpp::traits::input_parameter< double& >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< bool >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(d_half_cauchy(x, sigma, logd));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_d_half_cauchy(SEXP xSEXP, SEXP sigmaSEXP, SEXP logdSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_d_half_cauchy_try(xSEXP, sigmaSEXP, logdSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dMVN
double dMVN(const arma::mat& y, const arma::vec& mu, const arma::mat& Sigma_chol, const bool logd);
static SEXP BayesComposition_dMVN_try(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    Rcpp::traits::input_parameter< const bool >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(dMVN(y, mu, Sigma_chol, logd));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_dMVN(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_dMVN_try(ySEXP, muSEXP, Sigma_cholSEXP, logdSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dMVNChol
double dMVNChol(const arma::vec& y, const arma::vec& mu, const arma::mat& Sigma_chol, const bool logd);
static SEXP BayesComposition_dMVNChol_try(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    Rcpp::traits::input_parameter< const bool >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(dMVNChol(y, mu, Sigma_chol, logd));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_dMVNChol(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_dMVNChol_try(ySEXP, muSEXP, Sigma_cholSEXP, logdSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// LL_DM
double LL_DM(const arma::mat& alpha, const arma::mat& Y, const double& N, const double& d, const arma::vec& count);
static SEXP BayesComposition_LL_DM_try(SEXP alphaSEXP, SEXP YSEXP, SEXP NSEXP, SEXP dSEXP, SEXP countSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const double& >::type N(NSEXP);
    Rcpp::traits::input_parameter< const double& >::type d(dSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type count(countSEXP);
    rcpp_result_gen = Rcpp::wrap(LL_DM(alpha, Y, N, d, count));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_LL_DM(SEXP alphaSEXP, SEXP YSEXP, SEXP NSEXP, SEXP dSEXP, SEXP countSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_LL_DM_try(alphaSEXP, YSEXP, NSEXP, dSEXP, countSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// LL_DM_row
double LL_DM_row(const arma::rowvec& alpha, const arma::rowvec& Y, const double& d, const double& count);
static SEXP BayesComposition_LL_DM_row_try(SEXP alphaSEXP, SEXP YSEXP, SEXP dSEXP, SEXP countSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::rowvec& >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::rowvec& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const double& >::type d(dSEXP);
    Rcpp::traits::input_parameter< const double& >::type count(countSEXP);
    rcpp_result_gen = Rcpp::wrap(LL_DM_row(alpha, Y, d, count));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_LL_DM_row(SEXP alphaSEXP, SEXP YSEXP, SEXP dSEXP, SEXP countSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_LL_DM_row_try(alphaSEXP, YSEXP, dSEXP, countSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logDet
double logDet(const arma::mat Sig);
static SEXP BayesComposition_logDet_try(SEXP SigSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type Sig(SigSEXP);
    rcpp_result_gen = Rcpp::wrap(logDet(Sig));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_logDet(SEXP SigSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_logDet_try(SigSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logDetChol
double logDetChol(const arma::mat Sig_chol);
static SEXP BayesComposition_logDetChol_try(SEXP Sig_cholSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type Sig_chol(Sig_cholSEXP);
    rcpp_result_gen = Rcpp::wrap(logDetChol(Sig_chol));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_logDetChol(SEXP Sig_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_logDetChol_try(Sig_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logit
arma::vec logit(const arma::vec& phi);
static SEXP BayesComposition_logit_try(SEXP phiSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type phi(phiSEXP);
    rcpp_result_gen = Rcpp::wrap(logit(phi));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_logit(SEXP phiSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_logit_try(phiSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// expit
arma::vec expit(const arma::vec& phi);
static SEXP BayesComposition_expit_try(SEXP phiSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type phi(phiSEXP);
    rcpp_result_gen = Rcpp::wrap(expit(phi));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_expit(SEXP phiSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_expit_try(phiSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeUpperLKJ
arma::mat makeUpperLKJ(const arma::vec& x, const int& d);
static SEXP BayesComposition_makeUpperLKJ_try(SEXP xSEXP, SEXP dSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int& >::type d(dSEXP);
    rcpp_result_gen = Rcpp::wrap(makeUpperLKJ(x, d));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_makeUpperLKJ(SEXP xSEXP, SEXP dSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_makeUpperLKJ_try(xSEXP, dSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeRLKJ
Rcpp::List makeRLKJ(const arma::vec& xi, const int& d, bool cholesky, bool jacobian);
static SEXP BayesComposition_makeRLKJ_try(SEXP xiSEXP, SEXP dSEXP, SEXP choleskySEXP, SEXP jacobianSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type xi(xiSEXP);
    Rcpp::traits::input_parameter< const int& >::type d(dSEXP);
    Rcpp::traits::input_parameter< bool >::type cholesky(choleskySEXP);
    Rcpp::traits::input_parameter< bool >::type jacobian(jacobianSEXP);
    rcpp_result_gen = Rcpp::wrap(makeRLKJ(xi, d, cholesky, jacobian));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_makeRLKJ(SEXP xiSEXP, SEXP dSEXP, SEXP choleskySEXP, SEXP jacobianSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_makeRLKJ_try(xiSEXP, dSEXP, choleskySEXP, jacobianSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeDistARMA
arma::mat makeDistARMA(const arma::mat& coords1, const arma::mat& coords2);
static SEXP BayesComposition_makeDistARMA_try(SEXP coords1SEXP, SEXP coords2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type coords1(coords1SEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type coords2(coords2SEXP);
    rcpp_result_gen = Rcpp::wrap(makeDistARMA(coords1, coords2));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_makeDistARMA(SEXP coords1SEXP, SEXP coords2SEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_makeDistARMA_try(coords1SEXP, coords2SEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeQinv
arma::mat makeQinv(const double& theta, const int& t);
static SEXP BayesComposition_makeQinv_try(SEXP thetaSEXP, SEXP tSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double& >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< const int& >::type t(tSEXP);
    rcpp_result_gen = Rcpp::wrap(makeQinv(theta, t));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_makeQinv(SEXP thetaSEXP, SEXP tSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_makeQinv_try(thetaSEXP, tSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mcmcRcppDM
List mcmcRcppDM(const arma::mat& Y, const arma::vec& X, const arma::mat& Y_pred, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP BayesComposition_mcmcRcppDM(SEXP YSEXP, SEXP XSEXP, SEXP Y_predSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDM(Y, X, Y_pred, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMBasis
List predictRcppDMBasis(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP BayesComposition_predictRcppDMBasis(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMBasis(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMBasis
List mcmcRcppDMBasis(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP BayesComposition_mcmcRcppDMBasis(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMBasis(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppGAM
List mcmcRcppGAM(const arma::mat& Y, const arma::vec& X_input, List params, int n_chain, std::string file_name);
RcppExport SEXP BayesComposition_mcmcRcppGAM(SEXP YSEXP, SEXP X_inputSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X_input(X_inputSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppGAM(Y, X_input, params, n_chain, file_name));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppMVGP
List predictRcppMVGP(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP BayesComposition_predictRcppMVGP(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppMVGP(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppMVGP
List mcmcRcppMVGP(const arma::mat& Y, const arma::vec& X, List params, int n_chain, std::string file_name);
RcppExport SEXP BayesComposition_mcmcRcppMVGP(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppMVGP(Y, X, params, n_chain, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mvrnormArma
arma::mat mvrnormArma(const int& n, const arma::vec& mu, const arma::mat& Sigma);
static SEXP BayesComposition_mvrnormArma_try(SEXP nSEXP, SEXP muSEXP, SEXP SigmaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int& >::type n(nSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma(SigmaSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArma(n, mu, Sigma));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_mvrnormArma(SEXP nSEXP, SEXP muSEXP, SEXP SigmaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_mvrnormArma_try(nSEXP, muSEXP, SigmaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mvrnormArmaVec
arma::vec mvrnormArmaVec(const arma::vec& mu, const arma::mat& Sigma);
static SEXP BayesComposition_mvrnormArmaVec_try(SEXP muSEXP, SEXP SigmaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma(SigmaSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArmaVec(mu, Sigma));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_mvrnormArmaVec(SEXP muSEXP, SEXP SigmaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_mvrnormArmaVec_try(muSEXP, SigmaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mvrnormArmaChol
arma::mat mvrnormArmaChol(const int& n, const arma::vec& mu, const arma::mat& Sigma_chol);
static SEXP BayesComposition_mvrnormArmaChol_try(SEXP nSEXP, SEXP muSEXP, SEXP Sigma_cholSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int& >::type n(nSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArmaChol(n, mu, Sigma_chol));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_mvrnormArmaChol(SEXP nSEXP, SEXP muSEXP, SEXP Sigma_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_mvrnormArmaChol_try(nSEXP, muSEXP, Sigma_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mvrnormArmaVecChol
arma::vec mvrnormArmaVecChol(const arma::vec& mu, const arma::mat& Sigma_chol);
static SEXP BayesComposition_mvrnormArmaVecChol_try(SEXP muSEXP, SEXP Sigma_cholSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArmaVecChol(mu, Sigma_chol));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_mvrnormArmaVecChol(SEXP muSEXP, SEXP Sigma_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_mvrnormArmaVecChol_try(muSEXP, Sigma_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rMVNArma
arma::vec rMVNArma(arma::mat& A, arma::vec& b);
static SEXP BayesComposition_rMVNArma_try(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat& >::type A(ASEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(rMVNArma(A, b));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_rMVNArma(SEXP ASEXP, SEXP bSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_rMVNArma_try(ASEXP, bSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rMVNArmaScalar
double rMVNArmaScalar(const double& a, const double& b);
static SEXP BayesComposition_rMVNArmaScalar_try(SEXP aSEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double& >::type a(aSEXP);
    Rcpp::traits::input_parameter< const double& >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(rMVNArmaScalar(a, b));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_rMVNArmaScalar(SEXP aSEXP, SEXP bSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_rMVNArmaScalar_try(aSEXP, bSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// seq_lenC
arma::vec seq_lenC(const int& n);
static SEXP BayesComposition_seq_lenC_try(SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int& >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(seq_lenC(n));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_seq_lenC(SEXP nSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_seq_lenC_try(nSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuning
void updateTuning(const int k, double& accept_tmp, double& tune);
static SEXP BayesComposition_updateTuning_try(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int >::type k(kSEXP);
    Rcpp::traits::input_parameter< double& >::type accept_tmp(accept_tmpSEXP);
    Rcpp::traits::input_parameter< double& >::type tune(tuneSEXP);
    updateTuning(k, accept_tmp, tune);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_updateTuning(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_updateTuning_try(kSEXP, accept_tmpSEXP, tuneSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningVec
void updateTuningVec(const int k, arma::vec& accept_tmp, arma::vec& tune);
static SEXP BayesComposition_updateTuningVec_try(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int >::type k(kSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type accept_tmp(accept_tmpSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type tune(tuneSEXP);
    updateTuningVec(k, accept_tmp, tune);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_updateTuningVec(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_updateTuningVec_try(kSEXP, accept_tmpSEXP, tuneSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningMat
void updateTuningMat(const int k, arma::mat& accept_tmp, arma::mat& tune);
static SEXP BayesComposition_updateTuningMat_try(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int >::type k(kSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type accept_tmp(accept_tmpSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type tune(tuneSEXP);
    updateTuningMat(k, accept_tmp, tune);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_updateTuningMat(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_updateTuningMat_try(kSEXP, accept_tmpSEXP, tuneSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningMV
void updateTuningMV(const int& k, double& accept_rate, double& lambda, arma::mat& batch_samples, arma::mat& Sigma_tune, arma::mat Sigma_tune_chol);
static SEXP BayesComposition_updateTuningMV_try(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int& >::type k(kSEXP);
    Rcpp::traits::input_parameter< double& >::type accept_rate(accept_rateSEXP);
    Rcpp::traits::input_parameter< double& >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type batch_samples(batch_samplesSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type Sigma_tune(Sigma_tuneSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type Sigma_tune_chol(Sigma_tune_cholSEXP);
    updateTuningMV(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_updateTuningMV(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_updateTuningMV_try(kSEXP, accept_rateSEXP, lambdaSEXP, batch_samplesSEXP, Sigma_tuneSEXP, Sigma_tune_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningMVMat
void updateTuningMVMat(const int& k, arma::vec& accept_rate, arma::vec& lambda, arma::cube& batch_samples, arma::cube& Sigma_tune, arma::cube Sigma_tune_chol);
static SEXP BayesComposition_updateTuningMVMat_try(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int& >::type k(kSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type accept_rate(accept_rateSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< arma::cube& >::type batch_samples(batch_samplesSEXP);
    Rcpp::traits::input_parameter< arma::cube& >::type Sigma_tune(Sigma_tuneSEXP);
    Rcpp::traits::input_parameter< arma::cube >::type Sigma_tune_chol(Sigma_tune_cholSEXP);
    updateTuningMVMat(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP BayesComposition_updateTuningMVMat(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(BayesComposition_updateTuningMVMat_try(kSEXP, accept_rateSEXP, lambdaSEXP, batch_samplesSEXP, Sigma_tuneSEXP, Sigma_tune_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int BayesComposition_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("double(*basis_cpp)(const double&,const int&,const int&,const arma::vec&)");
        signatures.insert("arma::mat(*bs_cpp)(const arma::vec&,const int&,const arma::vec&,const int&,const bool&,const arma::vec&)");
        signatures.insert("arma::vec(*colSums)(const arma::mat&)");
        signatures.insert("double(*d_half_cauchy)(double&,double&,bool)");
        signatures.insert("double(*dMVN)(const arma::mat&,const arma::vec&,const arma::mat&,const bool)");
        signatures.insert("double(*dMVNChol)(const arma::vec&,const arma::vec&,const arma::mat&,const bool)");
        signatures.insert("double(*LL_DM)(const arma::mat&,const arma::mat&,const double&,const double&,const arma::vec&)");
        signatures.insert("double(*LL_DM_row)(const arma::rowvec&,const arma::rowvec&,const double&,const double&)");
        signatures.insert("double(*logDet)(const arma::mat)");
        signatures.insert("double(*logDetChol)(const arma::mat)");
        signatures.insert("arma::vec(*logit)(const arma::vec&)");
        signatures.insert("arma::vec(*expit)(const arma::vec&)");
        signatures.insert("arma::mat(*makeUpperLKJ)(const arma::vec&,const int&)");
        signatures.insert("Rcpp::List(*makeRLKJ)(const arma::vec&,const int&,bool,bool)");
        signatures.insert("arma::mat(*makeDistARMA)(const arma::mat&,const arma::mat&)");
        signatures.insert("arma::mat(*makeQinv)(const double&,const int&)");
        signatures.insert("arma::mat(*mvrnormArma)(const int&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*mvrnormArmaVec)(const arma::vec&,const arma::mat&)");
        signatures.insert("arma::mat(*mvrnormArmaChol)(const int&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*mvrnormArmaVecChol)(const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*rMVNArma)(arma::mat&,arma::vec&)");
        signatures.insert("double(*rMVNArmaScalar)(const double&,const double&)");
        signatures.insert("arma::vec(*seq_lenC)(const int&)");
        signatures.insert("void(*updateTuning)(const int,double&,double&)");
        signatures.insert("void(*updateTuningVec)(const int,arma::vec&,arma::vec&)");
        signatures.insert("void(*updateTuningMat)(const int,arma::mat&,arma::mat&)");
        signatures.insert("void(*updateTuningMV)(const int&,double&,double&,arma::mat&,arma::mat&,arma::mat)");
        signatures.insert("void(*updateTuningMVMat)(const int&,arma::vec&,arma::vec&,arma::cube&,arma::cube&,arma::cube)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP BayesComposition_RcppExport_registerCCallable() { 
    R_RegisterCCallable("BayesComposition", "BayesComposition_basis_cpp", (DL_FUNC)BayesComposition_basis_cpp_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_bs_cpp", (DL_FUNC)BayesComposition_bs_cpp_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_colSums", (DL_FUNC)BayesComposition_colSums_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_d_half_cauchy", (DL_FUNC)BayesComposition_d_half_cauchy_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_dMVN", (DL_FUNC)BayesComposition_dMVN_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_dMVNChol", (DL_FUNC)BayesComposition_dMVNChol_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_LL_DM", (DL_FUNC)BayesComposition_LL_DM_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_LL_DM_row", (DL_FUNC)BayesComposition_LL_DM_row_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_logDet", (DL_FUNC)BayesComposition_logDet_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_logDetChol", (DL_FUNC)BayesComposition_logDetChol_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_logit", (DL_FUNC)BayesComposition_logit_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_expit", (DL_FUNC)BayesComposition_expit_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_makeUpperLKJ", (DL_FUNC)BayesComposition_makeUpperLKJ_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_makeRLKJ", (DL_FUNC)BayesComposition_makeRLKJ_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_makeDistARMA", (DL_FUNC)BayesComposition_makeDistARMA_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_makeQinv", (DL_FUNC)BayesComposition_makeQinv_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_mvrnormArma", (DL_FUNC)BayesComposition_mvrnormArma_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_mvrnormArmaVec", (DL_FUNC)BayesComposition_mvrnormArmaVec_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_mvrnormArmaChol", (DL_FUNC)BayesComposition_mvrnormArmaChol_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_mvrnormArmaVecChol", (DL_FUNC)BayesComposition_mvrnormArmaVecChol_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_rMVNArma", (DL_FUNC)BayesComposition_rMVNArma_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_rMVNArmaScalar", (DL_FUNC)BayesComposition_rMVNArmaScalar_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_seq_lenC", (DL_FUNC)BayesComposition_seq_lenC_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_updateTuning", (DL_FUNC)BayesComposition_updateTuning_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_updateTuningVec", (DL_FUNC)BayesComposition_updateTuningVec_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_updateTuningMat", (DL_FUNC)BayesComposition_updateTuningMat_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_updateTuningMV", (DL_FUNC)BayesComposition_updateTuningMV_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_updateTuningMVMat", (DL_FUNC)BayesComposition_updateTuningMVMat_try);
    R_RegisterCCallable("BayesComposition", "BayesComposition_RcppExport_validate", (DL_FUNC)BayesComposition_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"BayesComposition_basis_cpp", (DL_FUNC) &BayesComposition_basis_cpp, 4},
    {"BayesComposition_bs_cpp", (DL_FUNC) &BayesComposition_bs_cpp, 6},
    {"BayesComposition_colSums", (DL_FUNC) &BayesComposition_colSums, 1},
    {"BayesComposition_d_half_cauchy", (DL_FUNC) &BayesComposition_d_half_cauchy, 3},
    {"BayesComposition_dMVN", (DL_FUNC) &BayesComposition_dMVN, 4},
    {"BayesComposition_dMVNChol", (DL_FUNC) &BayesComposition_dMVNChol, 4},
    {"BayesComposition_LL_DM", (DL_FUNC) &BayesComposition_LL_DM, 5},
    {"BayesComposition_LL_DM_row", (DL_FUNC) &BayesComposition_LL_DM_row, 4},
    {"BayesComposition_logDet", (DL_FUNC) &BayesComposition_logDet, 1},
    {"BayesComposition_logDetChol", (DL_FUNC) &BayesComposition_logDetChol, 1},
    {"BayesComposition_logit", (DL_FUNC) &BayesComposition_logit, 1},
    {"BayesComposition_expit", (DL_FUNC) &BayesComposition_expit, 1},
    {"BayesComposition_makeUpperLKJ", (DL_FUNC) &BayesComposition_makeUpperLKJ, 2},
    {"BayesComposition_makeRLKJ", (DL_FUNC) &BayesComposition_makeRLKJ, 4},
    {"BayesComposition_makeDistARMA", (DL_FUNC) &BayesComposition_makeDistARMA, 2},
    {"BayesComposition_makeQinv", (DL_FUNC) &BayesComposition_makeQinv, 2},
    {"BayesComposition_mcmcRcppDM", (DL_FUNC) &BayesComposition_mcmcRcppDM, 8},
    {"BayesComposition_predictRcppDMBasis", (DL_FUNC) &BayesComposition_predictRcppDMBasis, 8},
    {"BayesComposition_mcmcRcppDMBasis", (DL_FUNC) &BayesComposition_mcmcRcppDMBasis, 7},
    {"BayesComposition_mcmcRcppGAM", (DL_FUNC) &BayesComposition_mcmcRcppGAM, 5},
    {"BayesComposition_predictRcppMVGP", (DL_FUNC) &BayesComposition_predictRcppMVGP, 8},
    {"BayesComposition_mcmcRcppMVGP", (DL_FUNC) &BayesComposition_mcmcRcppMVGP, 5},
    {"BayesComposition_mvrnormArma", (DL_FUNC) &BayesComposition_mvrnormArma, 3},
    {"BayesComposition_mvrnormArmaVec", (DL_FUNC) &BayesComposition_mvrnormArmaVec, 2},
    {"BayesComposition_mvrnormArmaChol", (DL_FUNC) &BayesComposition_mvrnormArmaChol, 3},
    {"BayesComposition_mvrnormArmaVecChol", (DL_FUNC) &BayesComposition_mvrnormArmaVecChol, 2},
    {"BayesComposition_rMVNArma", (DL_FUNC) &BayesComposition_rMVNArma, 2},
    {"BayesComposition_rMVNArmaScalar", (DL_FUNC) &BayesComposition_rMVNArmaScalar, 2},
    {"BayesComposition_seq_lenC", (DL_FUNC) &BayesComposition_seq_lenC, 1},
    {"BayesComposition_updateTuning", (DL_FUNC) &BayesComposition_updateTuning, 3},
    {"BayesComposition_updateTuningVec", (DL_FUNC) &BayesComposition_updateTuningVec, 3},
    {"BayesComposition_updateTuningMat", (DL_FUNC) &BayesComposition_updateTuningMat, 3},
    {"BayesComposition_updateTuningMV", (DL_FUNC) &BayesComposition_updateTuningMV, 6},
    {"BayesComposition_updateTuningMVMat", (DL_FUNC) &BayesComposition_updateTuningMVMat, 6},
    {"BayesComposition_RcppExport_registerCCallable", (DL_FUNC) &BayesComposition_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_BayesComposition(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
