// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/BayesComposition.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// basis_cpp
double basis_cpp(const double& x, const int& degree, const int& i, const arma::vec& knots);
static SEXP _BayesComposition_basis_cpp_try(SEXP xSEXP, SEXP degreeSEXP, SEXP iSEXP, SEXP knotsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int& >::type degree(degreeSEXP);
    Rcpp::traits::input_parameter< const int& >::type i(iSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type knots(knotsSEXP);
    rcpp_result_gen = Rcpp::wrap(basis_cpp(x, degree, i, knots));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_basis_cpp(SEXP xSEXP, SEXP degreeSEXP, SEXP iSEXP, SEXP knotsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_basis_cpp_try(xSEXP, degreeSEXP, iSEXP, knotsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// bs_cpp
arma::mat bs_cpp(const arma::vec& x, const int& df, const arma::vec& interior_knots, const int& degree, const bool& intercept, const arma::vec& Boundary_knots);
static SEXP _BayesComposition_bs_cpp_try(SEXP xSEXP, SEXP dfSEXP, SEXP interior_knotsSEXP, SEXP degreeSEXP, SEXP interceptSEXP, SEXP Boundary_knotsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int& >::type df(dfSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type interior_knots(interior_knotsSEXP);
    Rcpp::traits::input_parameter< const int& >::type degree(degreeSEXP);
    Rcpp::traits::input_parameter< const bool& >::type intercept(interceptSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type Boundary_knots(Boundary_knotsSEXP);
    rcpp_result_gen = Rcpp::wrap(bs_cpp(x, df, interior_knots, degree, intercept, Boundary_knots));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_bs_cpp(SEXP xSEXP, SEXP dfSEXP, SEXP interior_knotsSEXP, SEXP degreeSEXP, SEXP interceptSEXP, SEXP Boundary_knotsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_bs_cpp_try(xSEXP, dfSEXP, interior_knotsSEXP, degreeSEXP, interceptSEXP, Boundary_knotsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// colSums
arma::vec colSums(const arma::mat& X);
static SEXP _BayesComposition_colSums_try(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(colSums(X));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_colSums(SEXP XSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_colSums_try(XSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// d_half_cauchy
double d_half_cauchy(double& x, double& sigma, bool logd);
static SEXP _BayesComposition_d_half_cauchy_try(SEXP xSEXP, SEXP sigmaSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double& >::type x(xSEXP);
    Rcpp::traits::input_parameter< double& >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< bool >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(d_half_cauchy(x, sigma, logd));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_d_half_cauchy(SEXP xSEXP, SEXP sigmaSEXP, SEXP logdSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_d_half_cauchy_try(xSEXP, sigmaSEXP, logdSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dMVN
double dMVN(const arma::mat& y, const arma::vec& mu, const arma::mat& Sigma_chol, const bool logd);
static SEXP _BayesComposition_dMVN_try(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    Rcpp::traits::input_parameter< const bool >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(dMVN(y, mu, Sigma_chol, logd));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_dMVN(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_dMVN_try(ySEXP, muSEXP, Sigma_cholSEXP, logdSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dMVNChol
double dMVNChol(const arma::vec& y, const arma::vec& mu, const arma::mat& Sigma_chol, const bool logd);
static SEXP _BayesComposition_dMVNChol_try(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type y(ySEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    Rcpp::traits::input_parameter< const bool >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(dMVNChol(y, mu, Sigma_chol, logd));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_dMVNChol(SEXP ySEXP, SEXP muSEXP, SEXP Sigma_cholSEXP, SEXP logdSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_dMVNChol_try(ySEXP, muSEXP, Sigma_cholSEXP, logdSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// LL_DM
double LL_DM(const arma::mat& alpha, const arma::mat& Y, const double& N, const double& d, const arma::vec& count);
static SEXP _BayesComposition_LL_DM_try(SEXP alphaSEXP, SEXP YSEXP, SEXP NSEXP, SEXP dSEXP, SEXP countSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const double& >::type N(NSEXP);
    Rcpp::traits::input_parameter< const double& >::type d(dSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type count(countSEXP);
    rcpp_result_gen = Rcpp::wrap(LL_DM(alpha, Y, N, d, count));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_LL_DM(SEXP alphaSEXP, SEXP YSEXP, SEXP NSEXP, SEXP dSEXP, SEXP countSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_LL_DM_try(alphaSEXP, YSEXP, NSEXP, dSEXP, countSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// LL_DM_row
double LL_DM_row(const arma::rowvec& alpha, const arma::rowvec& Y, const double& d, const double& count);
static SEXP _BayesComposition_LL_DM_row_try(SEXP alphaSEXP, SEXP YSEXP, SEXP dSEXP, SEXP countSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::rowvec& >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::rowvec& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const double& >::type d(dSEXP);
    Rcpp::traits::input_parameter< const double& >::type count(countSEXP);
    rcpp_result_gen = Rcpp::wrap(LL_DM_row(alpha, Y, d, count));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_LL_DM_row(SEXP alphaSEXP, SEXP YSEXP, SEXP dSEXP, SEXP countSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_LL_DM_row_try(alphaSEXP, YSEXP, dSEXP, countSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logDet
double logDet(const arma::mat Sig);
static SEXP _BayesComposition_logDet_try(SEXP SigSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type Sig(SigSEXP);
    rcpp_result_gen = Rcpp::wrap(logDet(Sig));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_logDet(SEXP SigSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_logDet_try(SigSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logDetChol
double logDetChol(const arma::mat Sig_chol);
static SEXP _BayesComposition_logDetChol_try(SEXP Sig_cholSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type Sig_chol(Sig_cholSEXP);
    rcpp_result_gen = Rcpp::wrap(logDetChol(Sig_chol));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_logDetChol(SEXP Sig_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_logDetChol_try(Sig_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logit
arma::vec logit(const arma::vec& phi);
static SEXP _BayesComposition_logit_try(SEXP phiSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type phi(phiSEXP);
    rcpp_result_gen = Rcpp::wrap(logit(phi));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_logit(SEXP phiSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_logit_try(phiSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// expit
arma::vec expit(const arma::vec& phi);
static SEXP _BayesComposition_expit_try(SEXP phiSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type phi(phiSEXP);
    rcpp_result_gen = Rcpp::wrap(expit(phi));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_expit(SEXP phiSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_expit_try(phiSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logit_double
double logit_double(const double& phi);
static SEXP _BayesComposition_logit_double_try(SEXP phiSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double& >::type phi(phiSEXP);
    rcpp_result_gen = Rcpp::wrap(logit_double(phi));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_logit_double(SEXP phiSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_logit_double_try(phiSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// expit_double
double expit_double(double& phi);
static SEXP _BayesComposition_expit_double_try(SEXP phiSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double& >::type phi(phiSEXP);
    rcpp_result_gen = Rcpp::wrap(expit_double(phi));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_expit_double(SEXP phiSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_expit_double_try(phiSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeUpperLKJ
arma::mat makeUpperLKJ(const arma::vec& x, const int& d);
static SEXP _BayesComposition_makeUpperLKJ_try(SEXP xSEXP, SEXP dSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int& >::type d(dSEXP);
    rcpp_result_gen = Rcpp::wrap(makeUpperLKJ(x, d));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_makeUpperLKJ(SEXP xSEXP, SEXP dSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_makeUpperLKJ_try(xSEXP, dSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeRLKJ
Rcpp::List makeRLKJ(const arma::vec& xi, const int& d, bool cholesky, bool jacobian);
static SEXP _BayesComposition_makeRLKJ_try(SEXP xiSEXP, SEXP dSEXP, SEXP choleskySEXP, SEXP jacobianSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type xi(xiSEXP);
    Rcpp::traits::input_parameter< const int& >::type d(dSEXP);
    Rcpp::traits::input_parameter< bool >::type cholesky(choleskySEXP);
    Rcpp::traits::input_parameter< bool >::type jacobian(jacobianSEXP);
    rcpp_result_gen = Rcpp::wrap(makeRLKJ(xi, d, cholesky, jacobian));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_makeRLKJ(SEXP xiSEXP, SEXP dSEXP, SEXP choleskySEXP, SEXP jacobianSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_makeRLKJ_try(xiSEXP, dSEXP, choleskySEXP, jacobianSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeCRPS
arma::vec makeCRPS(const arma::mat& estimate, const arma::vec& truth, const int& n_samps);
static SEXP _BayesComposition_makeCRPS_try(SEXP estimateSEXP, SEXP truthSEXP, SEXP n_sampsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type estimate(estimateSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type truth(truthSEXP);
    Rcpp::traits::input_parameter< const int& >::type n_samps(n_sampsSEXP);
    rcpp_result_gen = Rcpp::wrap(makeCRPS(estimate, truth, n_samps));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_makeCRPS(SEXP estimateSEXP, SEXP truthSEXP, SEXP n_sampsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_makeCRPS_try(estimateSEXP, truthSEXP, n_sampsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeDistARMA
arma::mat makeDistARMA(const arma::mat& coords1, const arma::mat& coords2);
static SEXP _BayesComposition_makeDistARMA_try(SEXP coords1SEXP, SEXP coords2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type coords1(coords1SEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type coords2(coords2SEXP);
    rcpp_result_gen = Rcpp::wrap(makeDistARMA(coords1, coords2));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_makeDistARMA(SEXP coords1SEXP, SEXP coords2SEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_makeDistARMA_try(coords1SEXP, coords2SEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// makeQinv
arma::mat makeQinv(const double& theta, const int& t);
static SEXP _BayesComposition_makeQinv_try(SEXP thetaSEXP, SEXP tSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double& >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< const int& >::type t(tSEXP);
    rcpp_result_gen = Rcpp::wrap(makeQinv(theta, t));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_makeQinv(SEXP thetaSEXP, SEXP tSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_makeQinv_try(thetaSEXP, tSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// predictRcppDMMVGPAdditive
List predictRcppDMMVGPAdditive(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMMVGPAdditive(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMMVGPAdditive(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMMVGPAdditive
List mcmcRcppDMMVGPAdditive(const arma::mat& Y, const arma::vec& X, List params, int n_chain, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMMVGPAdditive(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMMVGPAdditive(Y, X, params, n_chain, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMMVGPMultiplicativeAdditive
List predictRcppDMMVGPMultiplicativeAdditive(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMMVGPMultiplicativeAdditive(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMMVGPMultiplicativeAdditive(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMMVGPMultiplicativeAdditive
List mcmcRcppDMMVGPMultiplicativeAdditive(const arma::mat& Y, const arma::vec& X, List params, int n_chain, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMMVGPMultiplicativeAdditive(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMMVGPMultiplicativeAdditive(Y, X, params, n_chain, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMMVGPMultiplicative
List predictRcppDMMVGPMultiplicative(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMMVGPMultiplicative(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMMVGPMultiplicative(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMMVGPMultiplicative
List mcmcRcppDMMVGPMultiplicative(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMMVGPMultiplicative(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMMVGPMultiplicative(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMMVGP
List predictRcppDMMVGP(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMMVGP(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMMVGP(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMMVGP
List mcmcRcppDMMVGP(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMMVGP(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMMVGP(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMBasisAdditive
List predictRcppDMBasisAdditive(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMBasisAdditive(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMBasisAdditive(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMBasisAdditive
List mcmcRcppDMBasisAdditive(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMBasisAdditive(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMBasisAdditive(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// csample
arma::vec csample(arma::vec x, int size, bool replace, NumericVector prob);
RcppExport SEXP _BayesComposition_csample(SEXP xSEXP, SEXP sizeSEXP, SEXP replaceSEXP, SEXP probSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< int >::type size(sizeSEXP);
    Rcpp::traits::input_parameter< bool >::type replace(replaceSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type prob(probSEXP);
    rcpp_result_gen = Rcpp::wrap(csample(x, size, replace, prob));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMBasisMixture
List mcmcRcppDMBasisMixture(const arma::mat& Y, const arma::vec& X, List params, int n_chain, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMBasisMixture(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMBasisMixture(Y, X, params, n_chain, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMBasisMultiplicativeAdditive
List predictRcppDMBasisMultiplicativeAdditive(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMBasisMultiplicativeAdditive(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMBasisMultiplicativeAdditive(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMBasisMultiplicativeAdditive
List mcmcRcppDMBasisMultiplicativeAdditive(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMBasisMultiplicativeAdditive(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMBasisMultiplicativeAdditive(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMBasisMultiplicative
List predictRcppDMBasisMultiplicative(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMBasisMultiplicative(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMBasisMultiplicative(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMBasisMultiplicative
List mcmcRcppDMBasisMultiplicative(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMBasisMultiplicative(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMBasisMultiplicative(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMBasis
List predictRcppDMBasis(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMBasis(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMBasis(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMBasis
List mcmcRcppDMBasis(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMBasis(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMBasis(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppDMBummer
List predictRcppDMBummer(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppDMBummer(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppDMBummer(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMBummer
List mcmcRcppDMBummer(const arma::mat& Y, const arma::vec& X, List params, int n_chain, std::string file_name);
RcppExport SEXP _BayesComposition_mcmcRcppDMBummer(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMBummer(Y, X, params, n_chain, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppDMLinear
List mcmcRcppDMLinear(const arma::mat& Y, const arma::vec& X, List params, int n_chain, bool pool_s2_tau2, std::string file_name, std::string corr_function);
RcppExport SEXP _BayesComposition_mcmcRcppDMLinear(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP pool_s2_tau2SEXP, SEXP file_nameSEXP, SEXP corr_functionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< bool >::type pool_s2_tau2(pool_s2_tau2SEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    Rcpp::traits::input_parameter< std::string >::type corr_function(corr_functionSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppDMLinear(Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppBasis
List predictRcppBasis(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppBasis(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppBasis(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppGAM
List mcmcRcppGAM(const arma::mat& Y, const arma::vec& X_input, List params, int n_chain, std::string file_name);
RcppExport SEXP _BayesComposition_mcmcRcppGAM(SEXP YSEXP, SEXP X_inputSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X_input(X_inputSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppGAM(Y, X_input, params, n_chain, file_name));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppMVGP
List predictRcppMVGP(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppMVGP(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppMVGP(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppMVGP
List mcmcRcppMVGP(const arma::mat& Y, const arma::vec& X, List params, int n_chain, std::string file_name);
RcppExport SEXP _BayesComposition_mcmcRcppMVGP(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppMVGP(Y, X, params, n_chain, file_name));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppMVGPMultiplicative
List predictRcppMVGPMultiplicative(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppMVGPMultiplicative(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppMVGPMultiplicative(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// predictRcppMVGPOlder
List predictRcppMVGPOlder(const arma::mat& Y_pred, const double mu_X, const double s2_X, const double min_X, const double max_X, List params, List samples, std::string file_name);
RcppExport SEXP _BayesComposition_predictRcppMVGPOlder(SEXP Y_predSEXP, SEXP mu_XSEXP, SEXP s2_XSEXP, SEXP min_XSEXP, SEXP max_XSEXP, SEXP paramsSEXP, SEXP samplesSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y_pred(Y_predSEXP);
    Rcpp::traits::input_parameter< const double >::type mu_X(mu_XSEXP);
    Rcpp::traits::input_parameter< const double >::type s2_X(s2_XSEXP);
    Rcpp::traits::input_parameter< const double >::type min_X(min_XSEXP);
    Rcpp::traits::input_parameter< const double >::type max_X(max_XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< List >::type samples(samplesSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(predictRcppMVGPOlder(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mcmcRcppMVGPDiag
List mcmcRcppMVGPDiag(const arma::mat& Y, const arma::vec& X, List params, int n_chain, std::string file_name);
RcppExport SEXP _BayesComposition_mcmcRcppMVGPDiag(SEXP YSEXP, SEXP XSEXP, SEXP paramsSEXP, SEXP n_chainSEXP, SEXP file_nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type X(XSEXP);
    Rcpp::traits::input_parameter< List >::type params(paramsSEXP);
    Rcpp::traits::input_parameter< int >::type n_chain(n_chainSEXP);
    Rcpp::traits::input_parameter< std::string >::type file_name(file_nameSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmcRcppMVGPDiag(Y, X, params, n_chain, file_name));
    return rcpp_result_gen;
END_RCPP
}
// mvrnormArma
arma::mat mvrnormArma(const int& n, const arma::vec& mu, const arma::mat& Sigma);
static SEXP _BayesComposition_mvrnormArma_try(SEXP nSEXP, SEXP muSEXP, SEXP SigmaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int& >::type n(nSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma(SigmaSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArma(n, mu, Sigma));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_mvrnormArma(SEXP nSEXP, SEXP muSEXP, SEXP SigmaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_mvrnormArma_try(nSEXP, muSEXP, SigmaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mvrnormArmaVec
arma::vec mvrnormArmaVec(const arma::vec& mu, const arma::mat& Sigma);
static SEXP _BayesComposition_mvrnormArmaVec_try(SEXP muSEXP, SEXP SigmaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma(SigmaSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArmaVec(mu, Sigma));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_mvrnormArmaVec(SEXP muSEXP, SEXP SigmaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_mvrnormArmaVec_try(muSEXP, SigmaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mvrnormArmaChol
arma::mat mvrnormArmaChol(const int& n, const arma::vec& mu, const arma::mat& Sigma_chol);
static SEXP _BayesComposition_mvrnormArmaChol_try(SEXP nSEXP, SEXP muSEXP, SEXP Sigma_cholSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int& >::type n(nSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArmaChol(n, mu, Sigma_chol));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_mvrnormArmaChol(SEXP nSEXP, SEXP muSEXP, SEXP Sigma_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_mvrnormArmaChol_try(nSEXP, muSEXP, Sigma_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mvrnormArmaVecChol
arma::vec mvrnormArmaVecChol(const arma::vec& mu, const arma::mat& Sigma_chol);
static SEXP _BayesComposition_mvrnormArmaVecChol_try(SEXP muSEXP, SEXP Sigma_cholSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Sigma_chol(Sigma_cholSEXP);
    rcpp_result_gen = Rcpp::wrap(mvrnormArmaVecChol(mu, Sigma_chol));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_mvrnormArmaVecChol(SEXP muSEXP, SEXP Sigma_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_mvrnormArmaVecChol_try(muSEXP, Sigma_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rMVNArma
arma::vec rMVNArma(arma::mat& A, arma::vec& b);
static SEXP _BayesComposition_rMVNArma_try(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat& >::type A(ASEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(rMVNArma(A, b));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_rMVNArma(SEXP ASEXP, SEXP bSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_rMVNArma_try(ASEXP, bSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rMVNArmaScalar
double rMVNArmaScalar(const double& a, const double& b);
static SEXP _BayesComposition_rMVNArmaScalar_try(SEXP aSEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double& >::type a(aSEXP);
    Rcpp::traits::input_parameter< const double& >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(rMVNArmaScalar(a, b));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_rMVNArmaScalar(SEXP aSEXP, SEXP bSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_rMVNArmaScalar_try(aSEXP, bSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rWishartArmaMat
arma::mat rWishartArmaMat(const unsigned int& df, const arma::mat& S);
static SEXP _BayesComposition_rWishartArmaMat_try(SEXP dfSEXP, SEXP SSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const unsigned int& >::type df(dfSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type S(SSEXP);
    rcpp_result_gen = Rcpp::wrap(rWishartArmaMat(df, S));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_rWishartArmaMat(SEXP dfSEXP, SEXP SSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_rWishartArmaMat_try(dfSEXP, SSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rIWishartArmaMat
arma::mat rIWishartArmaMat(const unsigned int& df, const arma::mat& S);
static SEXP _BayesComposition_rIWishartArmaMat_try(SEXP dfSEXP, SEXP SSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const unsigned int& >::type df(dfSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type S(SSEXP);
    rcpp_result_gen = Rcpp::wrap(rIWishartArmaMat(df, S));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_rIWishartArmaMat(SEXP dfSEXP, SEXP SSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_rIWishartArmaMat_try(dfSEXP, SSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// seq_lenC
arma::vec seq_lenC(const int& n);
static SEXP _BayesComposition_seq_lenC_try(SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int& >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(seq_lenC(n));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_seq_lenC(SEXP nSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_seq_lenC_try(nSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuning
void updateTuning(const int k, double& accept_tmp, double& tune);
static SEXP _BayesComposition_updateTuning_try(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int >::type k(kSEXP);
    Rcpp::traits::input_parameter< double& >::type accept_tmp(accept_tmpSEXP);
    Rcpp::traits::input_parameter< double& >::type tune(tuneSEXP);
    updateTuning(k, accept_tmp, tune);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_updateTuning(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_updateTuning_try(kSEXP, accept_tmpSEXP, tuneSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningVec
void updateTuningVec(const int k, arma::vec& accept_tmp, arma::vec& tune);
static SEXP _BayesComposition_updateTuningVec_try(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int >::type k(kSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type accept_tmp(accept_tmpSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type tune(tuneSEXP);
    updateTuningVec(k, accept_tmp, tune);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_updateTuningVec(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_updateTuningVec_try(kSEXP, accept_tmpSEXP, tuneSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningMat
void updateTuningMat(const int k, arma::mat& accept_tmp, arma::mat& tune);
static SEXP _BayesComposition_updateTuningMat_try(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int >::type k(kSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type accept_tmp(accept_tmpSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type tune(tuneSEXP);
    updateTuningMat(k, accept_tmp, tune);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_updateTuningMat(SEXP kSEXP, SEXP accept_tmpSEXP, SEXP tuneSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_updateTuningMat_try(kSEXP, accept_tmpSEXP, tuneSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningMV
void updateTuningMV(const int& k, double& accept_rate, double& lambda, arma::mat& batch_samples, arma::mat& Sigma_tune, arma::mat Sigma_tune_chol);
static SEXP _BayesComposition_updateTuningMV_try(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int& >::type k(kSEXP);
    Rcpp::traits::input_parameter< double& >::type accept_rate(accept_rateSEXP);
    Rcpp::traits::input_parameter< double& >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type batch_samples(batch_samplesSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type Sigma_tune(Sigma_tuneSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type Sigma_tune_chol(Sigma_tune_cholSEXP);
    updateTuningMV(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_updateTuningMV(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_updateTuningMV_try(kSEXP, accept_rateSEXP, lambdaSEXP, batch_samplesSEXP, Sigma_tuneSEXP, Sigma_tune_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// updateTuningMVMat
void updateTuningMVMat(const int& k, arma::vec& accept_rate, arma::vec& lambda, arma::cube& batch_samples, arma::cube& Sigma_tune, arma::cube Sigma_tune_chol);
static SEXP _BayesComposition_updateTuningMVMat_try(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< const int& >::type k(kSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type accept_rate(accept_rateSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< arma::cube& >::type batch_samples(batch_samplesSEXP);
    Rcpp::traits::input_parameter< arma::cube& >::type Sigma_tune(Sigma_tuneSEXP);
    Rcpp::traits::input_parameter< arma::cube >::type Sigma_tune_chol(Sigma_tune_cholSEXP);
    updateTuningMVMat(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesComposition_updateTuningMVMat(SEXP kSEXP, SEXP accept_rateSEXP, SEXP lambdaSEXP, SEXP batch_samplesSEXP, SEXP Sigma_tuneSEXP, SEXP Sigma_tune_cholSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesComposition_updateTuningMVMat_try(kSEXP, accept_rateSEXP, lambdaSEXP, batch_samplesSEXP, Sigma_tuneSEXP, Sigma_tune_cholSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _BayesComposition_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("double(*basis_cpp)(const double&,const int&,const int&,const arma::vec&)");
        signatures.insert("arma::mat(*bs_cpp)(const arma::vec&,const int&,const arma::vec&,const int&,const bool&,const arma::vec&)");
        signatures.insert("arma::vec(*colSums)(const arma::mat&)");
        signatures.insert("double(*d_half_cauchy)(double&,double&,bool)");
        signatures.insert("double(*dMVN)(const arma::mat&,const arma::vec&,const arma::mat&,const bool)");
        signatures.insert("double(*dMVNChol)(const arma::vec&,const arma::vec&,const arma::mat&,const bool)");
        signatures.insert("double(*LL_DM)(const arma::mat&,const arma::mat&,const double&,const double&,const arma::vec&)");
        signatures.insert("double(*LL_DM_row)(const arma::rowvec&,const arma::rowvec&,const double&,const double&)");
        signatures.insert("double(*logDet)(const arma::mat)");
        signatures.insert("double(*logDetChol)(const arma::mat)");
        signatures.insert("arma::vec(*logit)(const arma::vec&)");
        signatures.insert("arma::vec(*expit)(const arma::vec&)");
        signatures.insert("double(*logit_double)(const double&)");
        signatures.insert("double(*expit_double)(double&)");
        signatures.insert("arma::mat(*makeUpperLKJ)(const arma::vec&,const int&)");
        signatures.insert("Rcpp::List(*makeRLKJ)(const arma::vec&,const int&,bool,bool)");
        signatures.insert("arma::vec(*makeCRPS)(const arma::mat&,const arma::vec&,const int&)");
        signatures.insert("arma::mat(*makeDistARMA)(const arma::mat&,const arma::mat&)");
        signatures.insert("arma::mat(*makeQinv)(const double&,const int&)");
        signatures.insert("arma::mat(*mvrnormArma)(const int&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*mvrnormArmaVec)(const arma::vec&,const arma::mat&)");
        signatures.insert("arma::mat(*mvrnormArmaChol)(const int&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*mvrnormArmaVecChol)(const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*rMVNArma)(arma::mat&,arma::vec&)");
        signatures.insert("double(*rMVNArmaScalar)(const double&,const double&)");
        signatures.insert("arma::mat(*rWishartArmaMat)(const unsigned int&,const arma::mat&)");
        signatures.insert("arma::mat(*rIWishartArmaMat)(const unsigned int&,const arma::mat&)");
        signatures.insert("arma::vec(*seq_lenC)(const int&)");
        signatures.insert("void(*updateTuning)(const int,double&,double&)");
        signatures.insert("void(*updateTuningVec)(const int,arma::vec&,arma::vec&)");
        signatures.insert("void(*updateTuningMat)(const int,arma::mat&,arma::mat&)");
        signatures.insert("void(*updateTuningMV)(const int&,double&,double&,arma::mat&,arma::mat&,arma::mat)");
        signatures.insert("void(*updateTuningMVMat)(const int&,arma::vec&,arma::vec&,arma::cube&,arma::cube&,arma::cube)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _BayesComposition_RcppExport_registerCCallable() { 
    R_RegisterCCallable("BayesComposition", "_BayesComposition_basis_cpp", (DL_FUNC)_BayesComposition_basis_cpp_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_bs_cpp", (DL_FUNC)_BayesComposition_bs_cpp_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_colSums", (DL_FUNC)_BayesComposition_colSums_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_d_half_cauchy", (DL_FUNC)_BayesComposition_d_half_cauchy_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_dMVN", (DL_FUNC)_BayesComposition_dMVN_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_dMVNChol", (DL_FUNC)_BayesComposition_dMVNChol_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_LL_DM", (DL_FUNC)_BayesComposition_LL_DM_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_LL_DM_row", (DL_FUNC)_BayesComposition_LL_DM_row_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_logDet", (DL_FUNC)_BayesComposition_logDet_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_logDetChol", (DL_FUNC)_BayesComposition_logDetChol_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_logit", (DL_FUNC)_BayesComposition_logit_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_expit", (DL_FUNC)_BayesComposition_expit_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_logit_double", (DL_FUNC)_BayesComposition_logit_double_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_expit_double", (DL_FUNC)_BayesComposition_expit_double_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_makeUpperLKJ", (DL_FUNC)_BayesComposition_makeUpperLKJ_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_makeRLKJ", (DL_FUNC)_BayesComposition_makeRLKJ_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_makeCRPS", (DL_FUNC)_BayesComposition_makeCRPS_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_makeDistARMA", (DL_FUNC)_BayesComposition_makeDistARMA_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_makeQinv", (DL_FUNC)_BayesComposition_makeQinv_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_mvrnormArma", (DL_FUNC)_BayesComposition_mvrnormArma_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_mvrnormArmaVec", (DL_FUNC)_BayesComposition_mvrnormArmaVec_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_mvrnormArmaChol", (DL_FUNC)_BayesComposition_mvrnormArmaChol_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_mvrnormArmaVecChol", (DL_FUNC)_BayesComposition_mvrnormArmaVecChol_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_rMVNArma", (DL_FUNC)_BayesComposition_rMVNArma_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_rMVNArmaScalar", (DL_FUNC)_BayesComposition_rMVNArmaScalar_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_rWishartArmaMat", (DL_FUNC)_BayesComposition_rWishartArmaMat_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_rIWishartArmaMat", (DL_FUNC)_BayesComposition_rIWishartArmaMat_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_seq_lenC", (DL_FUNC)_BayesComposition_seq_lenC_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_updateTuning", (DL_FUNC)_BayesComposition_updateTuning_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_updateTuningVec", (DL_FUNC)_BayesComposition_updateTuningVec_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_updateTuningMat", (DL_FUNC)_BayesComposition_updateTuningMat_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_updateTuningMV", (DL_FUNC)_BayesComposition_updateTuningMV_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_updateTuningMVMat", (DL_FUNC)_BayesComposition_updateTuningMVMat_try);
    R_RegisterCCallable("BayesComposition", "_BayesComposition_RcppExport_validate", (DL_FUNC)_BayesComposition_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_BayesComposition_basis_cpp", (DL_FUNC) &_BayesComposition_basis_cpp, 4},
    {"_BayesComposition_bs_cpp", (DL_FUNC) &_BayesComposition_bs_cpp, 6},
    {"_BayesComposition_colSums", (DL_FUNC) &_BayesComposition_colSums, 1},
    {"_BayesComposition_d_half_cauchy", (DL_FUNC) &_BayesComposition_d_half_cauchy, 3},
    {"_BayesComposition_dMVN", (DL_FUNC) &_BayesComposition_dMVN, 4},
    {"_BayesComposition_dMVNChol", (DL_FUNC) &_BayesComposition_dMVNChol, 4},
    {"_BayesComposition_LL_DM", (DL_FUNC) &_BayesComposition_LL_DM, 5},
    {"_BayesComposition_LL_DM_row", (DL_FUNC) &_BayesComposition_LL_DM_row, 4},
    {"_BayesComposition_logDet", (DL_FUNC) &_BayesComposition_logDet, 1},
    {"_BayesComposition_logDetChol", (DL_FUNC) &_BayesComposition_logDetChol, 1},
    {"_BayesComposition_logit", (DL_FUNC) &_BayesComposition_logit, 1},
    {"_BayesComposition_expit", (DL_FUNC) &_BayesComposition_expit, 1},
    {"_BayesComposition_logit_double", (DL_FUNC) &_BayesComposition_logit_double, 1},
    {"_BayesComposition_expit_double", (DL_FUNC) &_BayesComposition_expit_double, 1},
    {"_BayesComposition_makeUpperLKJ", (DL_FUNC) &_BayesComposition_makeUpperLKJ, 2},
    {"_BayesComposition_makeRLKJ", (DL_FUNC) &_BayesComposition_makeRLKJ, 4},
    {"_BayesComposition_makeCRPS", (DL_FUNC) &_BayesComposition_makeCRPS, 3},
    {"_BayesComposition_makeDistARMA", (DL_FUNC) &_BayesComposition_makeDistARMA, 2},
    {"_BayesComposition_makeQinv", (DL_FUNC) &_BayesComposition_makeQinv, 2},
    {"_BayesComposition_predictRcppDMMVGPAdditive", (DL_FUNC) &_BayesComposition_predictRcppDMMVGPAdditive, 8},
    {"_BayesComposition_mcmcRcppDMMVGPAdditive", (DL_FUNC) &_BayesComposition_mcmcRcppDMMVGPAdditive, 6},
    {"_BayesComposition_predictRcppDMMVGPMultiplicativeAdditive", (DL_FUNC) &_BayesComposition_predictRcppDMMVGPMultiplicativeAdditive, 8},
    {"_BayesComposition_mcmcRcppDMMVGPMultiplicativeAdditive", (DL_FUNC) &_BayesComposition_mcmcRcppDMMVGPMultiplicativeAdditive, 6},
    {"_BayesComposition_predictRcppDMMVGPMultiplicative", (DL_FUNC) &_BayesComposition_predictRcppDMMVGPMultiplicative, 8},
    {"_BayesComposition_mcmcRcppDMMVGPMultiplicative", (DL_FUNC) &_BayesComposition_mcmcRcppDMMVGPMultiplicative, 7},
    {"_BayesComposition_predictRcppDMMVGP", (DL_FUNC) &_BayesComposition_predictRcppDMMVGP, 8},
    {"_BayesComposition_mcmcRcppDMMVGP", (DL_FUNC) &_BayesComposition_mcmcRcppDMMVGP, 7},
    {"_BayesComposition_predictRcppDMBasisAdditive", (DL_FUNC) &_BayesComposition_predictRcppDMBasisAdditive, 8},
    {"_BayesComposition_mcmcRcppDMBasisAdditive", (DL_FUNC) &_BayesComposition_mcmcRcppDMBasisAdditive, 7},
    {"_BayesComposition_csample", (DL_FUNC) &_BayesComposition_csample, 4},
    {"_BayesComposition_mcmcRcppDMBasisMixture", (DL_FUNC) &_BayesComposition_mcmcRcppDMBasisMixture, 6},
    {"_BayesComposition_predictRcppDMBasisMultiplicativeAdditive", (DL_FUNC) &_BayesComposition_predictRcppDMBasisMultiplicativeAdditive, 8},
    {"_BayesComposition_mcmcRcppDMBasisMultiplicativeAdditive", (DL_FUNC) &_BayesComposition_mcmcRcppDMBasisMultiplicativeAdditive, 7},
    {"_BayesComposition_predictRcppDMBasisMultiplicative", (DL_FUNC) &_BayesComposition_predictRcppDMBasisMultiplicative, 8},
    {"_BayesComposition_mcmcRcppDMBasisMultiplicative", (DL_FUNC) &_BayesComposition_mcmcRcppDMBasisMultiplicative, 7},
    {"_BayesComposition_predictRcppDMBasis", (DL_FUNC) &_BayesComposition_predictRcppDMBasis, 8},
    {"_BayesComposition_mcmcRcppDMBasis", (DL_FUNC) &_BayesComposition_mcmcRcppDMBasis, 7},
    {"_BayesComposition_predictRcppDMBummer", (DL_FUNC) &_BayesComposition_predictRcppDMBummer, 8},
    {"_BayesComposition_mcmcRcppDMBummer", (DL_FUNC) &_BayesComposition_mcmcRcppDMBummer, 5},
    {"_BayesComposition_mcmcRcppDMLinear", (DL_FUNC) &_BayesComposition_mcmcRcppDMLinear, 7},
    {"_BayesComposition_predictRcppBasis", (DL_FUNC) &_BayesComposition_predictRcppBasis, 8},
    {"_BayesComposition_mcmcRcppGAM", (DL_FUNC) &_BayesComposition_mcmcRcppGAM, 5},
    {"_BayesComposition_predictRcppMVGP", (DL_FUNC) &_BayesComposition_predictRcppMVGP, 8},
    {"_BayesComposition_mcmcRcppMVGP", (DL_FUNC) &_BayesComposition_mcmcRcppMVGP, 5},
    {"_BayesComposition_predictRcppMVGPMultiplicative", (DL_FUNC) &_BayesComposition_predictRcppMVGPMultiplicative, 8},
    {"_BayesComposition_predictRcppMVGPOlder", (DL_FUNC) &_BayesComposition_predictRcppMVGPOlder, 8},
    {"_BayesComposition_mcmcRcppMVGPDiag", (DL_FUNC) &_BayesComposition_mcmcRcppMVGPDiag, 5},
    {"_BayesComposition_mvrnormArma", (DL_FUNC) &_BayesComposition_mvrnormArma, 3},
    {"_BayesComposition_mvrnormArmaVec", (DL_FUNC) &_BayesComposition_mvrnormArmaVec, 2},
    {"_BayesComposition_mvrnormArmaChol", (DL_FUNC) &_BayesComposition_mvrnormArmaChol, 3},
    {"_BayesComposition_mvrnormArmaVecChol", (DL_FUNC) &_BayesComposition_mvrnormArmaVecChol, 2},
    {"_BayesComposition_rMVNArma", (DL_FUNC) &_BayesComposition_rMVNArma, 2},
    {"_BayesComposition_rMVNArmaScalar", (DL_FUNC) &_BayesComposition_rMVNArmaScalar, 2},
    {"_BayesComposition_rWishartArmaMat", (DL_FUNC) &_BayesComposition_rWishartArmaMat, 2},
    {"_BayesComposition_rIWishartArmaMat", (DL_FUNC) &_BayesComposition_rIWishartArmaMat, 2},
    {"_BayesComposition_seq_lenC", (DL_FUNC) &_BayesComposition_seq_lenC, 1},
    {"_BayesComposition_updateTuning", (DL_FUNC) &_BayesComposition_updateTuning, 3},
    {"_BayesComposition_updateTuningVec", (DL_FUNC) &_BayesComposition_updateTuningVec, 3},
    {"_BayesComposition_updateTuningMat", (DL_FUNC) &_BayesComposition_updateTuningMat, 3},
    {"_BayesComposition_updateTuningMV", (DL_FUNC) &_BayesComposition_updateTuningMV, 6},
    {"_BayesComposition_updateTuningMVMat", (DL_FUNC) &_BayesComposition_updateTuningMVMat, 6},
    {"_BayesComposition_RcppExport_registerCCallable", (DL_FUNC) &_BayesComposition_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_BayesComposition(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
