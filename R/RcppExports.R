# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' A function for implementing the Cox-de Boor algorithm for constructing B-splines
#'
#' @param \code{x} A \code{double} that is the point at which to evaluate the Cox-de Boor algorithm
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{i} An \code{int} giving the knot index at which to evaluate the algorithm
#' @param \code{knots} A \code{vector} that contains the knot locations
#'
#' @return \code{basis_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
basis_cpp <- function(x, degree, i, knots) {
    .Call('BayesComposition_basis_cpp', PACKAGE = 'BayesComposition', x, degree, i, knots)
}

#' A function for implementing the Cox-de Boor algorithm for constructing B-splines
#'
#' @param \code{x} A \code{vector} that is the data at which to evaluate the Cox-de Boor algorithm
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{intercept} A \code{bool} of whether or not to include an intercept term in the basis expasion
#' @param \code{Boundary_knots} A \code{vector} that contains the boundary knot locations
#'
#' @return \code{bs_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
bs_cpp <- function(x, df, interior_knots, degree, intercept, Boundary_knots) {
    .Call('BayesComposition_bs_cpp', PACKAGE = 'BayesComposition', x, df, interior_knots, degree, intercept, Boundary_knots)
}

colSums <- function(X) {
    .Call('BayesComposition_colSums', PACKAGE = 'BayesComposition', X)
}

#' A function for generating an evenly spaced sequence of numbers between 0 and 1
#'
#' @param \code{n} An \code{int}
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{i} An \code{int} giving the knot index at which to evaluate the algorithm
#' @param \code{knots} A \code{vector} that contains the knot locations
#'
#' @return \code{basis_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
d_half_cauchy <- function(x, sigma, logd = TRUE) {
    .Call('BayesComposition_d_half_cauchy', PACKAGE = 'BayesComposition', x, sigma, logd)
}

dMVN <- function(y, mu, Sigma_chol, logd = TRUE) {
    .Call('BayesComposition_dMVN', PACKAGE = 'BayesComposition', y, mu, Sigma_chol, logd)
}

dMVNChol <- function(y, mu, Sigma_chol, logd = TRUE) {
    .Call('BayesComposition_dMVNChol', PACKAGE = 'BayesComposition', y, mu, Sigma_chol, logd)
}

#' A function for calculating the log-likelihood of a Dirichlet-Multinomial distribution over all observations
#'
#' @param \code{alpha} An \eqn{N \times d} \code{matrix} that represents the \eqn{N} realizations of the \eqn{d}-dimensional Dirichlet-multinomial parameters \eqn{alpha}
#' @param \code{Y} An \eqn{N \times d} \code{matrix} that represents the \eqn{N} observations of the \eqn{d}-dimensional Dirichlet-multinomial count data \eqn{Y}
#' @param \code{N} An \code{integer} of the number of observations
#' @param \code{d} An \code{integer} of the dimension of the process
#' @param \code{count} An \eqn{N}-dimensional \code{vector} of the number of draws for the multinomial process with one count per observtaion
#'
#' @return \code{LL_DM()} returns a double that is the evaluation of log-likelihood of the Dirichlet-multinomail distribution given the data and parameters
#' @export
LL_DM <- function(alpha, Y, N, d, count) {
    .Call('BayesComposition_LL_DM', PACKAGE = 'BayesComposition', alpha, Y, N, d, count)
}

LL_DM_row <- function(alpha, Y, d, count) {
    .Call('BayesComposition_LL_DM_row', PACKAGE = 'BayesComposition', alpha, Y, d, count)
}

logDet <- function(Sig) {
    .Call('BayesComposition_logDet', PACKAGE = 'BayesComposition', Sig)
}

logDetChol <- function(Sig_chol) {
    .Call('BayesComposition_logDetChol', PACKAGE = 'BayesComposition', Sig_chol)
}

#' A function for calculating the logit function
#'
#' @param \code{phi} A \code{vector} on the real line
#'
#' @return \code{logit()} returns the logit transform on \code{phi}
#' @export
logit <- function(phi) {
    .Call('BayesComposition_logit', PACKAGE = 'BayesComposition', phi)
}

#' A function for calculating the inverse logit function
#'
#' @param \code{phi} A \code{vector} on the interval (0, 1)
#'
#' @return \code{logit()} returns the inverse logit transform on \code{phi}
#' @export
expit <- function(phi) {
    .Call('BayesComposition_expit', PACKAGE = 'BayesComposition', phi)
}

#' A function for turning an \code{choose(d, 2)}-vector into a d by d matrix for use in constructing an upper-triangular Cholesky decomposition of a correlation matrix
#'
#' @param \code{xi} A \code{vector} of variables bounded between -1 and 1
#' @param \code{d} An \code{int} that gives the dimension of the correlation matrix
#'
#' @return \code{makeUpperLKJ()} returns an upper-triangular matrix
#' @export
makeUpperLKJ <- function(x, d) {
    .Call('BayesComposition_makeUpperLKJ', PACKAGE = 'BayesComposition', x, d)
}

#' A function for generating a d by d upper-triangular Cholesky decomposition of a correlation matrix using the helper function \code{makeUpperLKJ}
#'
#' @param \code{xi} A \code{vector} of variables bounded between -1 and 1
#' @param \code{d} An \code{int} that gives the dimension of the correlation matrix
#'
#' @return \code{makeRLKJ()} returns an upper-triangular Cholesky matrix \code{R} whose inner product \code{t(R)R} is a correlation matrix \code{Omega}. If \code{cholesky} = \code{TRUE}, \code{makeRLKJ} returns the correlation matrix \code{Omega}. If \code{jacobian} = \code{TRUE}, \code{makeRLKJ} calculates the jacobian of the transformation from a correlation matrix to a Cholesky factor. In general, the Jacobian is not needed.
#' @export
makeRLKJ <- function(xi, d, cholesky = FALSE, jacobian = FALSE) {
    .Call('BayesComposition_makeRLKJ', PACKAGE = 'BayesComposition', xi, d, cholesky, jacobian)
}

makeCRPS <- function(estimate, truth, n_samps) {
    .Call('BayesComposition_makeCRPS', PACKAGE = 'BayesComposition', estimate, truth, n_samps)
}

makeDistARMA <- function(coords1, coords2) {
    .Call('BayesComposition_makeDistARMA', PACKAGE = 'BayesComposition', coords1, coords2)
}

#' Makes a conditional autoregressive (CAR) precision matrix
#'
#' @param theta The CAR parameter
#' @param t The dimension of the CAR matrix
#'
#' @export
makeQinv <- function(theta, t) {
    .Call('BayesComposition_makeQinv', PACKAGE = 'BayesComposition', theta, t)
}

predictRcppDMMVGP <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-fit") {
    .Call('BayesComposition_predictRcppDMMVGP', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMMVGP <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('BayesComposition_mcmcRcppDMMVGP', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

predictRcppDMBasis <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-predict") {
    .Call('BayesComposition_predictRcppDMBasis', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMBasis <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('BayesComposition_mcmcRcppDMBasis', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

mcmcRcppGAM <- function(Y, X_input, params, n_chain = 1L, file_name = "gam") {
    .Call('BayesComposition_mcmcRcppGAM', PACKAGE = 'BayesComposition', Y, X_input, params, n_chain, file_name)
}

predictRcppMVGP <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "mvgp-predict") {
    .Call('BayesComposition_predictRcppMVGP', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppMVGP <- function(Y, X, params, n_chain = 1L, file_name = "sim-fit") {
    .Call('BayesComposition_mcmcRcppMVGP', PACKAGE = 'BayesComposition', Y, X, params, n_chain, file_name)
}

mvrnormArma <- function(n, mu, Sigma) {
    .Call('BayesComposition_mvrnormArma', PACKAGE = 'BayesComposition', n, mu, Sigma)
}

mvrnormArmaVec <- function(mu, Sigma) {
    .Call('BayesComposition_mvrnormArmaVec', PACKAGE = 'BayesComposition', mu, Sigma)
}

mvrnormArmaChol <- function(n, mu, Sigma_chol) {
    .Call('BayesComposition_mvrnormArmaChol', PACKAGE = 'BayesComposition', n, mu, Sigma_chol)
}

mvrnormArmaVecChol <- function(mu, Sigma_chol) {
    .Call('BayesComposition_mvrnormArmaVecChol', PACKAGE = 'BayesComposition', mu, Sigma_chol)
}

rMVNArma <- function(A, b) {
    .Call('BayesComposition_rMVNArma', PACKAGE = 'BayesComposition', A, b)
}

rMVNArmaScalar <- function(a, b) {
    .Call('BayesComposition_rMVNArmaScalar', PACKAGE = 'BayesComposition', a, b)
}

#' A function for generating an evenly spaced sequence of numbers between 0 and 1
#'
#' @param \code{n} An \code{int}
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{i} An \code{int} giving the knot index at which to evaluate the algorithm
#' @param \code{knots} A \code{vector} that contains the knot locations
#'
#' @return \code{basis_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
NULL

seq_lenC <- function(n) {
    .Call('BayesComposition_seq_lenC', PACKAGE = 'BayesComposition', n)
}

updateTuning <- function(k, accept_tmp, tune) {
    invisible(.Call('BayesComposition_updateTuning', PACKAGE = 'BayesComposition', k, accept_tmp, tune))
}

updateTuningVec <- function(k, accept_tmp, tune) {
    invisible(.Call('BayesComposition_updateTuningVec', PACKAGE = 'BayesComposition', k, accept_tmp, tune))
}

updateTuningMat <- function(k, accept_tmp, tune) {
    invisible(.Call('BayesComposition_updateTuningMat', PACKAGE = 'BayesComposition', k, accept_tmp, tune))
}

updateTuningMV <- function(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol) {
    invisible(.Call('BayesComposition_updateTuningMV', PACKAGE = 'BayesComposition', k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol))
}

updateTuningMVMat <- function(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol) {
    invisible(.Call('BayesComposition_updateTuningMVMat', PACKAGE = 'BayesComposition', k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol))
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('BayesComposition_RcppExport_registerCCallable', PACKAGE = 'BayesComposition')
})
