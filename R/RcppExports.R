# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' A function for implementing the Cox-de Boor algorithm for constructing B-splines
#'
#' @param \code{x} A \code{double} that is the point at which to evaluate the Cox-de Boor algorithm
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{i} An \code{int} giving the knot index at which to evaluate the algorithm
#' @param \code{knots} A \code{vector} that contains the knot locations
#'
#' @return \code{basis_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
basis_cpp <- function(x, degree, i, knots) {
    .Call('_BayesComposition_basis_cpp', PACKAGE = 'BayesComposition', x, degree, i, knots)
}

#' A function for implementing the Cox-de Boor algorithm for constructing B-splines
#'
#' @param \code{x} A \code{vector} that is the data at which to evaluate the Cox-de Boor algorithm
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{intercept} A \code{bool} of whether or not to include an intercept term in the basis expasion
#' @param \code{Boundary_knots} A \code{vector} that contains the boundary knot locations
#'
#' @return \code{bs_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
bs_cpp <- function(x, df, interior_knots, degree, intercept, Boundary_knots) {
    .Call('_BayesComposition_bs_cpp', PACKAGE = 'BayesComposition', x, df, interior_knots, degree, intercept, Boundary_knots)
}

colSums <- function(X) {
    .Call('_BayesComposition_colSums', PACKAGE = 'BayesComposition', X)
}

#' A function for generating an evenly spaced sequence of numbers between 0 and 1
#'
#' @param \code{n} An \code{int}
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{i} An \code{int} giving the knot index at which to evaluate the algorithm
#' @param \code{knots} A \code{vector} that contains the knot locations
#'
#' @return \code{basis_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
d_half_cauchy <- function(x, sigma, logd = TRUE) {
    .Call('_BayesComposition_d_half_cauchy', PACKAGE = 'BayesComposition', x, sigma, logd)
}

dMVN <- function(y, mu, Sigma_chol, logd = TRUE) {
    .Call('_BayesComposition_dMVN', PACKAGE = 'BayesComposition', y, mu, Sigma_chol, logd)
}

dMVNChol <- function(y, mu, Sigma_chol, logd = TRUE) {
    .Call('_BayesComposition_dMVNChol', PACKAGE = 'BayesComposition', y, mu, Sigma_chol, logd)
}

#' A function for calculating the log-likelihood of a Dirichlet-Multinomial distribution over all observations
#'
#' @param \code{alpha} An \eqn{N \times d} \code{matrix} that represents the \eqn{N} realizations of the \eqn{d}-dimensional Dirichlet-multinomial parameters \eqn{alpha}
#' @param \code{Y} An \eqn{N \times d} \code{matrix} that represents the \eqn{N} observations of the \eqn{d}-dimensional Dirichlet-multinomial count data \eqn{Y}
#' @param \code{N} An \code{integer} of the number of observations
#' @param \code{d} An \code{integer} of the dimension of the process
#' @param \code{count} An \eqn{N}-dimensional \code{vector} of the number of draws for the multinomial process with one count per observtaion
#'
#' @return \code{LL_DM()} returns a double that is the evaluation of log-likelihood of the Dirichlet-multinomail distribution given the data and parameters
#' @export
LL_DM <- function(alpha, Y, N, d, count) {
    .Call('_BayesComposition_LL_DM', PACKAGE = 'BayesComposition', alpha, Y, N, d, count)
}

LL_DM_row <- function(alpha, Y, d, count) {
    .Call('_BayesComposition_LL_DM_row', PACKAGE = 'BayesComposition', alpha, Y, d, count)
}

logDet <- function(Sig) {
    .Call('_BayesComposition_logDet', PACKAGE = 'BayesComposition', Sig)
}

logDetChol <- function(Sig_chol) {
    .Call('_BayesComposition_logDetChol', PACKAGE = 'BayesComposition', Sig_chol)
}

#' A function for calculating the logit function
#'
#' @param \code{phi} A \code{vector} on the real line
#'
#' @return \code{logit()} returns the logit transform on \code{phi}
#' @export
logit <- function(phi) {
    .Call('_BayesComposition_logit', PACKAGE = 'BayesComposition', phi)
}

#' A function for calculating the inverse logit function
#'
#' @param \code{phi} A \code{vector} on the interval (0, 1)
#'
#' @return \code{logit()} returns the inverse logit transform on \code{phi}
#' @export
expit <- function(phi) {
    .Call('_BayesComposition_expit', PACKAGE = 'BayesComposition', phi)
}

#' A function for turning an \code{choose(d, 2)}-vector into a d by d matrix for use in constructing an upper-triangular Cholesky decomposition of a correlation matrix
#'
#' @param \code{xi} A \code{vector} of variables bounded between -1 and 1
#' @param \code{d} An \code{int} that gives the dimension of the correlation matrix
#'
#' @return \code{makeUpperLKJ()} returns an upper-triangular matrix
#' @export
makeUpperLKJ <- function(x, d) {
    .Call('_BayesComposition_makeUpperLKJ', PACKAGE = 'BayesComposition', x, d)
}

#' A function for generating a d by d upper-triangular Cholesky decomposition of a correlation matrix using the helper function \code{makeUpperLKJ}
#'
#' @param \code{xi} A \code{vector} of variables bounded between -1 and 1
#' @param \code{d} An \code{int} that gives the dimension of the correlation matrix
#'
#' @return \code{makeRLKJ()} returns an upper-triangular Cholesky matrix \code{R} whose inner product \code{t(R)R} is a correlation matrix \code{Omega}. If \code{cholesky} = \code{TRUE}, \code{makeRLKJ} returns the correlation matrix \code{Omega}. If \code{jacobian} = \code{TRUE}, \code{makeRLKJ} calculates the jacobian of the transformation from a correlation matrix to a Cholesky factor. In general, the Jacobian is not needed.
#' @export
makeRLKJ <- function(xi, d, cholesky = FALSE, jacobian = FALSE) {
    .Call('_BayesComposition_makeRLKJ', PACKAGE = 'BayesComposition', xi, d, cholesky, jacobian)
}

makeCRPS <- function(estimate, truth, n_samps) {
    .Call('_BayesComposition_makeCRPS', PACKAGE = 'BayesComposition', estimate, truth, n_samps)
}

makeDistARMA <- function(coords1, coords2) {
    .Call('_BayesComposition_makeDistARMA', PACKAGE = 'BayesComposition', coords1, coords2)
}

#' Makes a conditional autoregressive (CAR) precision matrix
#'
#' @param theta The CAR parameter
#' @param t The dimension of the CAR matrix
#'
#' @export
makeQinv <- function(theta, t) {
    .Call('_BayesComposition_makeQinv', PACKAGE = 'BayesComposition', theta, t)
}

predictRcppDMMVGPAdditive <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-fit") {
    .Call('_BayesComposition_predictRcppDMMVGPAdditive', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMMVGPAdditive <- function(Y, X, params, n_chain = 1L, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMMVGPAdditive', PACKAGE = 'BayesComposition', Y, X, params, n_chain, file_name, corr_function)
}

predictRcppDMMVGPMultiplicativeAdditive <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-fit") {
    .Call('_BayesComposition_predictRcppDMMVGPMultiplicativeAdditive', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMMVGPMultiplicativeAdditive <- function(Y, X, params, n_chain = 1L, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMMVGPMultiplicativeAdditive', PACKAGE = 'BayesComposition', Y, X, params, n_chain, file_name, corr_function)
}

predictRcppDMMVGPMultiplicative <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-fit") {
    .Call('_BayesComposition_predictRcppDMMVGPMultiplicative', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMMVGPMultiplicative <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMMVGPMultiplicative', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

predictRcppDMMVGP <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-fit") {
    .Call('_BayesComposition_predictRcppDMMVGP', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMMVGP <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMMVGP', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

predictRcppDMBasisAdditive <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-predict") {
    .Call('_BayesComposition_predictRcppDMBasisAdditive', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMBasisAdditive <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMBasisAdditive', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

csample <- function(x, size, replace, prob) {
    .Call('_BayesComposition_csample', PACKAGE = 'BayesComposition', x, size, replace, prob)
}

mcmcRcppDMBasisMixture <- function(Y, X, params, n_chain = 1L, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMBasisMixture', PACKAGE = 'BayesComposition', Y, X, params, n_chain, file_name, corr_function)
}

predictRcppDMBasisMultiplicativeAdditive <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-predict") {
    .Call('_BayesComposition_predictRcppDMBasisMultiplicativeAdditive', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMBasisMultiplicativeAdditive <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMBasisMultiplicativeAdditive', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

predictRcppDMBasisMultiplicative <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-predict") {
    .Call('_BayesComposition_predictRcppDMBasisMultiplicative', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMBasisMultiplicative <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMBasisMultiplicative', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

predictRcppDMBasis <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-predict") {
    .Call('_BayesComposition_predictRcppDMBasis', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMBasis <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMBasis', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

predictRcppDMBummer <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "DM-predict") {
    .Call('_BayesComposition_predictRcppDMBummer', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppDMBummer <- function(Y, X, params, n_chain = 1L, file_name = "DM-fit") {
    .Call('_BayesComposition_mcmcRcppDMBummer', PACKAGE = 'BayesComposition', Y, X, params, n_chain, file_name)
}

mcmcRcppDMLinear <- function(Y, X, params, n_chain = 1L, pool_s2_tau2 = TRUE, file_name = "DM-fit", corr_function = "exponential") {
    .Call('_BayesComposition_mcmcRcppDMLinear', PACKAGE = 'BayesComposition', Y, X, params, n_chain, pool_s2_tau2, file_name, corr_function)
}

predictRcppBasis <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "mvgp-predict") {
    .Call('_BayesComposition_predictRcppBasis', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppGAM <- function(Y, X_input, params, n_chain = 1L, file_name = "gam") {
    .Call('_BayesComposition_mcmcRcppGAM', PACKAGE = 'BayesComposition', Y, X_input, params, n_chain, file_name)
}

predictRcppMVGP <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "mvgp-predict") {
    .Call('_BayesComposition_predictRcppMVGP', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppMVGP <- function(Y, X, params, n_chain = 1L, file_name = "sim-fit") {
    .Call('_BayesComposition_mcmcRcppMVGP', PACKAGE = 'BayesComposition', Y, X, params, n_chain, file_name)
}

predictRcppMVGPMultiplicative <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "mvgp-predict") {
    .Call('_BayesComposition_predictRcppMVGPMultiplicative', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

predictRcppMVGPOlder <- function(Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name = "mvgp-predict") {
    .Call('_BayesComposition_predictRcppMVGPOlder', PACKAGE = 'BayesComposition', Y_pred, mu_X, s2_X, min_X, max_X, params, samples, file_name)
}

mcmcRcppMVGPDiag <- function(Y, X, params, n_chain = 1L, file_name = "sim-fit") {
    .Call('_BayesComposition_mcmcRcppMVGPDiag', PACKAGE = 'BayesComposition', Y, X, params, n_chain, file_name)
}

mvrnormArma <- function(n, mu, Sigma) {
    .Call('_BayesComposition_mvrnormArma', PACKAGE = 'BayesComposition', n, mu, Sigma)
}

mvrnormArmaVec <- function(mu, Sigma) {
    .Call('_BayesComposition_mvrnormArmaVec', PACKAGE = 'BayesComposition', mu, Sigma)
}

mvrnormArmaChol <- function(n, mu, Sigma_chol) {
    .Call('_BayesComposition_mvrnormArmaChol', PACKAGE = 'BayesComposition', n, mu, Sigma_chol)
}

mvrnormArmaVecChol <- function(mu, Sigma_chol) {
    .Call('_BayesComposition_mvrnormArmaVecChol', PACKAGE = 'BayesComposition', mu, Sigma_chol)
}

rMVNArma <- function(A, b) {
    .Call('_BayesComposition_rMVNArma', PACKAGE = 'BayesComposition', A, b)
}

rMVNArmaScalar <- function(a, b) {
    .Call('_BayesComposition_rMVNArmaScalar', PACKAGE = 'BayesComposition', a, b)
}

#' @title Generate Random Wishart Distribution
#' @description Creates a random wishart distribution when given degrees of freedom and a sigma matrix.
#' @param df An \code{int}, which gives the degrees of freedom of the Wishart.  (> 0)
#' @param S A \code{matrix} with dimensions m x m that provides Sigma, the covariance matrix.
#' @return A \code{matrix} that is a Wishart distribution, aka the sample covariance matrix of a Multivariate Normal Distribution
#' @seealso \code{\link{riwishart}}
#' @author James J Balamuta
#' @examples
#' #Call with the following data:
#' rwishart(3, diag(2))
#'
#' # Validation
#' set.seed(1337)
#' S = toeplitz((10:1)/10)
#' n = 10000
#' o = array(dim = c(10,10,n))
#' for(i in 1:n){
#' o[,,i] = rwishart(20, S)
#' }
#' mR = apply(o, 1:2, mean)
#' Va = 20*(S^2 + tcrossprod(diag(S)))
#' vR = apply(o, 1:2, var)
#' stopifnot(all.equal(vR, Va, tolerance = 1/16))
#'
rWishartArmaMat <- function(df, S) {
    .Call('_BayesComposition_rWishartArmaMat', PACKAGE = 'BayesComposition', df, S)
}

#' @title Generate Random Inverse Wishart Distribution
#' @description Creates a random inverse wishart distribution when given degrees of freedom and a sigma matrix.
#' @param df An \code{int} that represents the degrees of freedom.  (> 0)
#' @param S A \code{matrix} with dimensions m x m that provides Sigma, the covariance matrix.
#' @return A \code{matrix} that is an inverse wishart distribution.
#' @seealso \code{\link{rwishart}}
#' @author James J Balamuta
#' @examples
#' #Call with the following data:
#' riwishart(3, diag(2))
rIWishartArmaMat <- function(df, S) {
    .Call('_BayesComposition_rIWishartArmaMat', PACKAGE = 'BayesComposition', df, S)
}

#' A function for generating an evenly spaced sequence of numbers between 0 and 1
#'
#' @param \code{n} An \code{int}
#' @param \code{degree} An \code{int} that gives the degree of the B-spline polynomial
#' @param \code{i} An \code{int} giving the knot index at which to evaluate the algorithm
#' @param \code{knots} A \code{vector} that contains the knot locations
#'
#' @return \code{basis_cpp()} returns a double that is the evaluation of the \code{degree}^{th} polynomial B-spline algorithm at location \code{x} for the $i$^{th} knot index given \code{knots}
#' @export
NULL

seq_lenC <- function(n) {
    .Call('_BayesComposition_seq_lenC', PACKAGE = 'BayesComposition', n)
}

updateTuning <- function(k, accept_tmp, tune) {
    invisible(.Call('_BayesComposition_updateTuning', PACKAGE = 'BayesComposition', k, accept_tmp, tune))
}

updateTuningVec <- function(k, accept_tmp, tune) {
    invisible(.Call('_BayesComposition_updateTuningVec', PACKAGE = 'BayesComposition', k, accept_tmp, tune))
}

updateTuningMat <- function(k, accept_tmp, tune) {
    invisible(.Call('_BayesComposition_updateTuningMat', PACKAGE = 'BayesComposition', k, accept_tmp, tune))
}

updateTuningMV <- function(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol) {
    invisible(.Call('_BayesComposition_updateTuningMV', PACKAGE = 'BayesComposition', k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol))
}

updateTuningMVMat <- function(k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol) {
    invisible(.Call('_BayesComposition_updateTuningMVMat', PACKAGE = 'BayesComposition', k, accept_rate, lambda, batch_samples, Sigma_tune, Sigma_tune_chol))
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_BayesComposition_RcppExport_registerCCallable', PACKAGE = 'BayesComposition')
})
